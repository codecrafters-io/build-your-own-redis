slug: "redis"
name: "Build your own Redis"
short_name: "Redis"
release_status: "live"

description_md: |-
  In this challenge, you'll build a toy Redis clone
  that's capable of handling basic commands like PING, GET
  and SET. Along the way, we'll learn about event loops, the Redis
  Protocol and more.

short_description_md: |-
  Learn about TCP servers, the Redis protocol and more

completion_percentage: 30
concept_slugs: ["network-protocols", "tcp-overview"]

languages:
  - slug: "c"
  - slug: "clojure"
  - slug: "cpp"
  - slug: "crystal"
  - slug: "csharp"
  - slug: "elixir"
  - slug: "go"
  - slug: "haskell"
  - slug: "java"
  - slug: "javascript"
  - slug: "php"
  - slug: "python"
  - slug: "ruby"
  - slug: "rust"

marketing:
  difficulty: medium
  sample_extension_idea_title: "Persistence"
  sample_extension_idea_description: "A Redis server that can read and write .rdb files"
  testimonials:
    - author_name: "Charles Guo"
      author_description: "Software Engineer, Stripe"
      author_avatar: "https://codecrafters.io/images/external/testimonials/charles-guo.png"
      link: "https://github.com/shaldengeki"
      text: |-
        The Redis challenge was extremely fun. I ended up having to read the
        Redis Protocol specification doc pretty carefully in its entirety! The result
        felt like lightly-guided independent study, if that makes sense. (Which, again, was lots of fun)
    - author_name: "Patrick Burris"
      author_description: "Senior Software Developer, CenturyLink"
      author_avatar: "https://codecrafters.io/images/external/testimonials/patrick-burris.jpeg"
      link: "https://github.com/Jumballaya"
      text: |-
        I think the instant feedback right there in the git push is really cool.
        Didn't even know that was possible!

extensions:
  - slug: "persistence-rdb"
    name: "RDB Persistence"
    description_markdown: |
      In this challenge extension you'll add [persistence][redis-persistence] support to your Redis implementation.

      Along the way you'll learn about Redis's [RDB file format][rdb-file-format] and more.

      [redis-persistence]: https://redis.io/docs/manual/persistence/
      [rdb-file-format]: https://github.com/sripathikrishnan/redis-rdb-tools/blob/548b11ec3c81a603f5b321228d07a61a0b940159/docs/RDB_File_Format.textile

  - slug: "replication"
    name: "Replication"
    description_markdown: |
      In this challenge extension you'll add support for [Replication][redis-replication] to your Redis implementation.

      Along the way you'll learn about how Redis's leader-follower replication works, the [PSYNC][redis-psync-command] command and more.

      [redis-replication]: https://redis.io/docs/management/replication/
      [redis-psync-command]: https://redis.io/commands/psync/

#   - slug: "streams"
#     name: "Streams"
#     description_markdown: |-
#       In this challenge extension you'll add support for the [Stream][redis-streams-data-type] data type to your Redis implementation.

#       Along the way you'll learn about commands like [XADD][xadd-command], [XRANGE][xrange-command] and more.

#       [redis-streams-data-type]: https://redis.io/docs/data-types/streams/
#       [xadd-command]: https://redis.io/commands/xadd/
#       [xrange-command]: https://redis.io/commands/xrange/

stages:
  - slug: "init"
    concept_slugs:
      ["network-protocols", "tcp-overview", "go-tcp-server", "rust-tcp-server"]
    name: "Bind to a port"
    description_md: |-
      Welcome to the Build your own Redis challenge! Now that you've got your repository set up, it's time to start building your Redis server.

      In this stage, you'll implement a TCP server that listens on port 6379.

      [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) is the underlying protocol used by protocols like HTTP, SSH and others
      you're probably familiar with. Redis clients & servers use TCP to communicate with each other.

      Don't worry if you're unfamiliar with the TCP protocol, or what Redis clients & servers are. You'll learn more about this in the
      next stages.

      ### Tests

      The tester will execute your program like this:

      ```bash
      $ ./spawn_redis_server.sh
      ```

      It'll then try to connect to your TCP server on port 6379. If the connection succeeds, you'll pass this stage.

      ### Notes

      - 6379 is the default port that Redis uses.
      - If you already have a Redis server running on your machine and listening on port 6379, you'll see a "port already in use" error when running your code. Try stopping the existing Redis server and running your code again.
    difficulty: very_easy
    marketing_md: |-
      In this stage, you'll start a TCP server on port 6379, which is the
      default port that Redis uses.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_bind.go#L11"

  - slug: "ping-pong"
    concept_slugs:
      ["network-protocols", "tcp-overview", "go-tcp-server", "rust-tcp-server"]
    name: "Respond to PING"
    difficulty: easy
    description_md: |-
      ðŸŽ‰ You now have a TCP server running on port 6379! It doesn't do anything useful yet though, let's change that.

      In this stage, you'll implement support for the [PING](https://redis.io/commands/ping) command.

      Redis clients communicate with Redis servers by sending "[commands](https://redis.io/commands/)". For each command, a Redis server sends a response back to the client.
      Commands and responses are both encoded using the [Redis protocol](https://redis.io/topics/protocol) (we'll learn more about this in later stages).

      [PING](https://redis.io/commands/ping/) is one of the simplest Redis commands. It's used to check whether a Redis server is healthy.

      The response for the `PING` command is `+PONG\r\n`. This is the string "PONG" encoded using the [Redis protocol](https://redis.io/docs/reference/protocol-spec/).

      In this stage, we'll cut corners by ignoring client input and hardcoding `+PONG\r\n` as a response. We'll learn to parse client input in later stages.

      ### Tests

      The tester will execute your program like this:

      ```bash
      $ ./spawn_redis_server.sh
      ```

      It'll then send a `PING` command to your server and expect a `+PONG\r\n` response.

      ```bash
      $ redis-cli ping
      ```

      Your server should respond with `+PONG\r\n`, which is "PONG" encoded as a [RESP simple string](https://redis.io/docs/reference/protocol-spec/#resp-simple-strings).

      ### Notes

      - You can ignore the data that the tester sends you for this stage. We'll get to parsing
      client input in later stages. For now, you can just hardcode `+PONG\r\n` as the response.
      - You can also ignore handling multiple clients and handling multiple PING commands in the stage, we'll get to that in later stages.
      - The exact bytes your program will receive won't be just `ping`, you'll receive something like this: `*1\r\n$4\r\nping\r\n`,
      which is the Redis protocol encoding of the `PING` command. We'll learn more about this in later stages.
    marketing_md: |
      In this stage, you'll respond to the
      [PING](https://redis.io/commands/ping) command. You'll use [the Redis
      protocol](https://redis.io/topics/protocol) to encode the reply.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_ping_pong.go#L9"

  - slug: "ping-pong-multiple"
    concept_slugs:
      ["network-protocols", "tcp-overview", "go-tcp-server", "rust-tcp-server"]
    name: "Respond to multiple PINGs"
    difficulty: easy
    description_md: |-
      In this stage, you'll respond to multiple
      [PING](https://redis.io/commands/ping) commands sent by the same connection.

      The tester will execute your program like this:

      ```bash
      $ ./spawn_redis_server.sh
      ```

      It'll then send two PING commands using the same connection:

      ```bash
      $ echo -e "ping\nping" | redis-cli
      ```

      The tester will expect to receive two `+PONG\r\n` responses.

      {{#lang_is_javascript}}
      In most languages, you'd need to run a loop that reads input from a connection and sends a
      response back. In JavaScript however, if you're listening to the
      [`data`](https://nodejs.org/api/net.html#net_event_data) event, this should be automatically handled for you. **It
      is very likely that the code you had for the previous stage will pass this stage without any changes!**
      {{/lang_is_javascript}}

      {{^lang_is_javascript}}
      You'll need to run a loop that reads input from a connection and sends a
      response back.
      {{/lang_is_javascript}}

      Just like the previous stage, you can hardcode `+PONG\r\n` as the response for this stage. We'll get to parsing
      client input in later stages.
    marketing_md: |-
      In this stage, you'll respond to multiple
      [PING](https://redis.io/commands/ping) commands sent by the same client.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_ping_pong.go#L35"

  - slug: "concurrent-clients"
    concept_slugs:
      ["network-protocols", "tcp-overview", "go-tcp-server", "rust-tcp-server"]
    name: "Handle concurrent clients"
    difficulty: medium
    description_md: |-
      In this stage, your server will need to handle multiple concurrent
      clients. Just like the previous stages, all clients will only send `PING`
      commands for now.

      {{#lang_is_javascript}}
      In most languages, you'd need to either use threads or implement an
      [Event Loop](https://en.wikipedia.org/wiki/Event_loop) to do this. In JavaScript however, since [the concurrency
      model itself is based on an event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), most
      standard library functions are designed to support this kind of concurrent behaviour out of the box. **It is very
      likely that the code you had for the previous stage will pass this stage without any changes!**
      {{/lang_is_javascript}}

      {{^lang_is_javascript}}
      To achieve this, you'll need to either use threads, or, if you're feeling
      adventurous, an [Event Loop](https://en.wikipedia.org/wiki/Event_loop) (like
      the official Redis implementation does).
      {{/lang_is_javascript}}

      Since the tester client _only_ sends the PING command at the moment, it's okay to
      ignore what the client sends and hardcode a response. We'll get to parsing
      client input in later stages.
    marketing_md: |-
      In this stage, you'll add support for multiple concurrent clients to your
      Redis server. To achieve this you'll use an [Event
      Loop](https://en.wikipedia.org/wiki/Event_loop),
      like the official Redis implementation does.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_ping_pong.go#L56"

  - slug: "echo"
    name: "Implement the ECHO command"
    difficulty: medium
    description_md: |-
      In this stage, you'll respond to the
      [ECHO](https://redis.io/commands/echo) command.

      The client will send you the command as a RESP array, which looks
      something like this:

      ```
      *2\r\n$4\r\nECHO\r\n$3\r\nhey\r\n
      ```

      Seems confusing? Read up about [sending commands to a Redis
      server](https://redis.io/docs/reference/protocol-spec/#sending-commands-to-a-redis-server).
    marketing_md: |-
      In this stage, you'll respond to the
      [ECHO](https://redis.io/commands/echo) command. You'll parse user input
      according to the [the Redis protocol
      specification](https://redis.io/topics/protocol).
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_echo.go#L11"

  # TODO: Change this to use hyphens
  - slug: "set_get"
    name: "Implement the SET & GET commands"
    difficulty: medium
    description_md: |-
      In this stage, you'll need to implement the [SET](https://redis.io/commands/set) &
      [GET](https://redis.io/commands/get) commands. For now, you can ignore all extra
      options for `SET` and just implement the simple form: `SET key value`. You'll add support
      for expiry in the next stage.
    marketing_md: |-
      In this stage, you'll need to implement the
      [SET](https://redis.io/commands/set) &
      [GET](https://redis.io/commands/get) commands.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/a58b9d58b33870fe26a164c0e323f809275a7250/internal/test_get_set.go#L11"

  - slug: "expiry"
    name: "Expiry"
    difficulty: medium
    description_md: |-
      In this stage, you'll need to support setting a key with an expiry. The
      expiry is provided in milliseconds using the "PX" argument to the
      [SET](https://redis.io/commands/set) command.

      The tester will do the following:

      ```bash
      # First, it'll set a key with an expiry (100 milliseconds in this example)
      $ redis-cli set random_key random_value px 100

      # Immediately after, it'll send a GET command to retrieve the value
      # The response to this should be "random_value" (encoded as a RESP bulk string)
      $ redis-cli get random_key

      # Then, it'll wait for the key to expire and send another GET command
      # The response to this should be `$-1\r\n` (a "null bulk string")
      $ sleep 0.2 && redis-cli get random_key
      ```

      {{#lang_is_haskell}}
      The [time](https://hackage.haskell.org/package/time) package is available
      to use as a dependency.
      {{/lang_is_haskell}}
    marketing_md: |-
      In this stage, you'll add support for setting a key with an expiry. The
      expiry is provided using the "PX" argument to the
      [SET](https://redis.io/commands/set) command.
    tester_source_code_url: "https://github.com/codecrafters-io/redis-tester/blob/master/internal/test_expiry.go"

  # Persistence

  - slug: "rdb-config"
    primary_extension_slug: "persistence-rdb"
    name: "RDB file config"
    difficulty: easy
    description_md: |
      Redis uses `.rdb` files for persistence. In this stage, you'll add support for reading the config values related to where RDB files are stored.

      There are two config values that determine where RDB files are stored:

      - `dir`: The directory where RDB files are stored
      - `dbfilename`: The name of the RDB file

      These values will be passed into your program like this:

      ```
      ./spawn_redis_server.sh --dir /tmp/redis-files --dbfilename dump.rdb
      ```

      To verify whether your program is reading config values correctly, the tester will send you two commands:

      ```bash
      redis-cli CONFIG GET dir
      redis-cli CONFIG GET dbfilename
      ```

      The response to `CONFIG GET <key>` should be a RESP array with two elements: the key and the value.

      For example, let's say the `dir` value is `/tmp/redis-files`. The expected response will be:

      ```
      *2\r\n$3\r\ndir\r\n$16\r\n/tmp/redis-files\r\n
      ```

      - `*2\r\n` indicates that the array has two elements
      - `$3\r\ndir\r\n` indicates that the first element is a bulk string with the value `dir`
      - `$16\r\n/tmp/redis-files\r\n` indicates that the second element is a bulk string with the value `/tmp/redis-files`

      **Note**: If your repository was created before 5th Oct 2023, it's possible that your `./spawn_redis_server.sh` script
      might not be passing arguments on to your program. You'll need to edit `./spawn_redis_server.sh` to fix this, check
      [this PR](https://github.com/codecrafters-io/build-your-own-redis/pull/89/files) for details.
    marketing_md: |
      In this stage, you'll add support for reading the config values related to where RDB files are stored. You'll implement the `CONFIG GET` command.

  - slug: "rdb-read-key"
    primary_extension_slug: "persistence-rdb"
    name: "Read a key"
    difficulty: medium
    description_md: |
      In this stage, you'll add support for reading a key from an RDB file.

      To keep things simple, we'll start out by supporting RDB files that contain a single key.

      Jan-Erik Rediger (author of [rdb-rs](https://rdb.fnordig.de/)) has a great [write-up](https://rdb.fnordig.de/file_format.html)
      that explains the RDB file format in detail. We recommend using it as a reference when working on this stage.

      The tester will create an RDB file with a single key and execute your program like this:

      ```
      ./spawn_redis_server.sh --dir <dir> --dbfilename <filename>
      ```

      It'll then send a `keys *` command to your server.

      ```bash
      $ redis-cli keys "*"
      ```

      The response to `keys *` should be a RESP array with one element: the key.

      For example, let's say the RDB file contains a key called `foo`. The expected response will be:

      ```
      *1\r\n$3\r\nfoo\r\n
      ```

      - `*1\r\n` indicates that the array has one element
      - `$3\r\nfoo\r\n` indicates that the first element is a bulk string with the value `foo`

      **Note**: Remember, in this stage you only need to support RDB files that contain a single key, and you can ignore the value of the key. We'll
      get to handling multiple keys and reading values in later stages.

      **Note**: The `.rdb` file provided via `--dir`/`--dbfilename` might not exist. If the file doesn't exist, your program must treat it as if the database
      is currently empty.
    marketing_md: |
      In this stage, you'll add support for reading a key from an RDB file that contains a single key-value pair. You'll do this by implementing the `KEYS *` command.

  - slug: "rdb-read-string-value"
    primary_extension_slug: "persistence-rdb"
    name: "Read a string value"
    difficulty: medium
    description_md: |
      In this stage, you'll add support for reading the value corresponding to a key from an RDB file.

      Just like with the previous stage, we'll stick to supporting RDB files that contain a single key for now.

      The tester will create an RDB file with a single key and execute your program like this:

      ```
      ./spawn_redis_server.sh --dir <dir> --dbfilename <filename>
      ```

      It'll then send a `get <key>` command to your server.

      ```bash
      $ redis-cli get "foo"
      ```

      The response to `get <key>` should be a RESP bulk string with the value of the key.

      For example, let's say the RDB file contains a key called `foo` with the value `bar`. The expected response will be `$3\r\nbar\r\n`.

      Strings can be encoded in three different ways in the RDB file format:

      - Length-prefixed strings
      - Integers as strings
      - Compressed strings

      In this stage, you only need to support length-prefixed strings. We won't cover the other two types in this challenge.

      We recommend using [this blog post](https://rdb.fnordig.de/file_format.html) as a reference when working on this stage.
    marketing_md: |
      In this stage, you'll add support for reading the value of a key from an RDB file that contains a single key-value pair.

  - slug: "rdb-read-multiple-keys"
    primary_extension_slug: "persistence-rdb"
    name: "Read multiple keys"
    difficulty: medium
    description_md: |
      In this stage, you'll add support for reading multiple keys from an RDB file.

      The tester will create an RDB file with multiple keys and execute your program like this:

      ```bash
      $ ./spawn_redis_server.sh --dir <dir> --dbfilename <filename>
      ```

      It'll then send a `keys *` command to your server.

      ```bash
      $ redis-cli keys "*"
      ```

      The response to `keys *` should be a RESP array with the keys as elements.

      For example, let's say the RDB file contains two keys: `foo` and `bar`. The expected response will be:

      ```
      *2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n
      ```

      - `*2\r\n` indicates that the array has two elements
      - `$3\r\nfoo\r\n` indicates that the first element is a bulk string with the value `foo`
      - `$3\r\nbar\r\n` indicates that the second element is a bulk string with the value `bar`
    marketing_md: |
      In this stage, you'll add support for reading multiple keys from an RDB file. You'll do this by extending the `KEYS *` command to support multiple keys.

  - slug: "rdb-read-multiple-string-values"
    primary_extension_slug: "persistence-rdb"
    name: "Read multiple string values"
    difficulty: medium
    description_md: |
      In this stage, you'll add support for reading multiple string values from an RDB file.

      The tester will create an RDB file with multiple keys and execute your program like this:

      ```bash
      $ ./spawn_redis_server.sh --dir <dir> --dbfilename <filename>
      ```

      It'll then send multiple `get <key>` commands to your server.

      ```bash
      $ redis-cli get "foo"
      $ redis-cli get "bar"
      ```

      The response to each `get <key>` command should be a RESP bulk string with the value corresponding to the key.
    marketing_md: |
      In this stage, you'll add support for reading multiple string values from an RDB file.

  - slug: "rdb-read-value-with-expiry"
    primary_extension_slug: "persistence-rdb"
    name: "Read value with expiry"
    difficulty: medium
    description_md: |
      In this stage, you'll add support for reading values that have an expiry set.

      The tester will create an RDB file with multiple keys. Some of these keys will have an expiry set, and some won't. The expiry timestamps
      will also be random, some will be in the past and some will be in the future.

      The tester will execute your program like this:

      ```bash
      $ ./spawn_redis_server.sh --dir <dir> --dbfilename <filename>
      ```

      It'll then send multiple `get <key>` commands to your server.

      ```bash
      $ redis-cli get "foo"
      $ redis-cli get "bar"
      ```

      When a key has expired, the expected response is `$-1\r\n` (a "null bulk string").

      When a key hasn't expired, the expected response is a RESP bulk string with the value corresponding to the key.
    marketing_md: |
      In this stage, you'll add support for reading values that have an expiry set.

  # Replication

  - slug: "repl-custom-port"
    primary_extension_slug: "replication"
    name: "Configure listening port"
    difficulty: easy
    description_md: |
      Welcome to the Replication extension!

      In this extension, you'll extend your Redis server to support [leader-follower replication](https://redis.io/docs/management/replication/). You'll be able to run
      multiple Redis servers with one acting as the "master" and the others as "replicas". Changes made to the master will be automatically replicated to the replicas.

      Since we'll need to run multiple instances of your Redis server at once, we can't run all of them on port 6379.

      In this stage, you'll add support for starting the Redis server on a custom port. The port number will be passed to your  the --port flag.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then try to connect to your TCP server on the specified port number (`<PORT>`). If the connection succeeds, you'll pass this stage.

      ### Notes

      - Your program still needs to pass the previous stages, so if `--port` isn't specified, you should default to port 6379.
    marketing_md: |
      In this stage, you'll add support for parsing the `--port` flag and starting Redis on a custom port.

  - slug: "repl-info"
    primary_extension_slug: "replication"
    name: "The INFO command"
    difficulty: easy
    description_md: |
      In this stage, you'll add support for the [INFO](https://redis.io/commands/info/) command.

      The `INFO` command returns information and statistics about a Redis server. In this stage, we'll add support for the
      `replication` section of the `INFO` command.

      ## The replication section

      When you run `redis-cli info replication` against a Redis server, you'll see something like this:

      ```
      # Replication
      role:master
      connected_slaves:0
      master_replid:8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb
      master_repl_offset:0
      second_repl_offset:-1
      repl_backlog_active:0
      repl_backlog_size:1048576
      repl_backlog_first_byte_offset:0
      repl_backlog_histlen:
      ```

      The reply to this command is a [Bulk string](https://redis.io/docs/reference/protocol-spec/#bulk-strings) where each line is a key value pair, seperated by ":".

      Here are what some of the important fields mean:

      - `role`: The role of the server (`master` or `slave`)
      - `connected_slaves`: The number of connected replicas
      - `master_replid`: The replication ID of the master (we'll get to this in later stages)
      - `master_repl_offset`: The replication offset of the master (we'll get to this in later stages)

      In this stage, you'll only need to support the `role` key. We'll add support for other keys in later stages.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then send the `INFO` command with `replication` as an argument.

      ```bash
      $ redis-cli info replication
      ```

      Your program should respond with a [Bulk string](https://redis.io/docs/reference/protocol-spec/#bulk-strings) where each line
      is a key value pair separated by ":". The tester will only look for the `role` key, and assert that the value is `master`.

      ## Notes

      - In the response for the `INFO` command, you only need to support the `role` key for this stage. We'll add support for the other keys in later stages.
      - The `# Replication` heading in the response is optional, you can ignore it.
      - The response to `INFO` needs to be encoded as a [Bulk string](https://redis.io/docs/reference/protocol-spec/#bulk-strings).
        - An example valid response would be `$11\r\nrole:master\r\n` (the string `role:master` encoded as a [Bulk string](https://redis.io/docs/reference/protocol-spec/#bulk-strings))
      - The `INFO` command can be used without any arguments, in which case it returns all sections available. In this stage, we'll
        always send `replication` as an argument to the `INFO` command, so you only need to support the `replication` section.
      ```

    marketing_md: |
      In this stage, you'll add support for the INFO command on the master.

  - slug: "repl-info-replica"
    primary_extension_slug: "replication"
    name: "The INFO command on a replica"
    difficulty: medium
    description_md: |
      In this stage, you'll add support for the [INFO](https://redis.io/commands/info/) command on the Replica redis server.

      But, before that you'll need to start the Redis server in Replica mode, and for that you'll need to add support for the `--replicaof` command line argument.
      To keep things simple, right now you don't need to do anything different, apart from changing the output of the `INFO` command.
      For the Replica the `INFO` command should return `role: slave`.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT> --replicaof <MASTER_HOST>:<MASTER_PORT>
      ```

      It'll then send the `INFO` command with `replication` as an argument to your server.

      ```bash
      $ redis-cli info replication
      ```

      The response to `info replication` should be a Bulk string, where each line is a key value pair, seperated by ":".
      We will only look for the `role` key, expecting a value of `slave`.
      You can ignore the `# Replication` heading.

    marketing_md: |
      In this stage, you'll add support for the --replicaof arg and INFO command on the replica.

  - slug: "repl-id"
    primary_extension_slug: "replication"
    name: "Initial Replication ID and Offset"
    difficulty: easy
    description_md: |
      Every Redis master has a replication ID: it is a large pseudo random string that marks a given story of the dataset. Each master also takes an offset that increments for every byte of replication stream that it is produced to be sent to replicas, to update the state of the replicas with the new changes modifying the dataset. The replication offset is incremented even if no replica is actually connected, so basically every given pair of:

      `Replication ID, offset`

      Identifies an exact version of the dataset of a master.

      In this stage, you'll initialize a replication ID and offset for your master. The ID can be any pseudo random alphanumeric string of 40 characters, and the offset is to be 0.
      Then add these 2 key value pairs to the INFO command output. The keys should be `master_replid` and `master_repl_offset`.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then send the `INFO` command with `replication` as an argument to your server.

      ```bash
      $ redis-cli info replication
      ```

      The response to `info replication` should be a Bulk string, where each line is a key value pair, seperated by ":".
      We will look for the `master_replid` key expecting a pseudorandom string and `master_repl_offset` key, expecting a value of `0`.
      You can ignore the `# Replication` heading.

    marketing_md: |
      In this stage, you'll add support for reading a key from an RDB file that contains a single key-value pair. You'll do this by implementing the `KEYS *` command.

  - slug: "repl-replica-ping"
    primary_extension_slug: "replication"
    name: "Send handshake 1/3"
    difficulty: easy
    description_md: |
      When replicas connect to masters, they begin a SYNC handshake, where in the first step the replica sends `PING` to the master.

      In this stage, you'll need to implement starting a handshake from the replica. The replica would be sending an `PING` to the master to start the handshake.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT> --replicaof <MASTER_HOST>:<MASTER_PORT>
      ```

      It'll expect to receive `PING` as the first command on the Master side.
      The command should be sent as a RESP Array, like this :
      `*1\r\n$4\r\nPING\r\n`

    marketing_md: |
      In this stage, you'll add support for starting the handshake from the Replica side.

  - slug: "repl-replica-replconf"
    primary_extension_slug: "replication"
    name: "Send handshake 2/3"
    difficulty: easy
    description_md: |
      After sending `PING` to the master, the replica will receive a `PONG` back.
      `PONG` would be sent as a RESP simple string, like this : `+PONG\r\n`

      After `PING`, the replica needs to send [REPLCONF](https://redis.io/commands/replconf/) to the master next.
      Send REPLCONF with the `listening-port` argument and your replica's port as the value.
      The command would look like this :
      `REPLCONF listening-port <REPLICA_PORT>`
      Send it as a RESP array.

      In this stage, you'll add support for accepting `PONG` after the sent `PING`, and then send the `REPLCONF` message.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT> --replicaof <MASTER_HOST>:<MASTER_PORT>
      ```

      It'll expect to receive `PING` as the first command on the Master side. It will send `PONG` back. It'll then expect to receive `REPLCONF` as the second command on the Master side.

    marketing_md: |
      In this stage, you'll add support for continuing the handshake from the Replica side, by sending REPLCONF.

  - slug: "repl-replica-psync"
    primary_extension_slug: "replication"
    name: "Send handshake 3/3 (Initiate PSYNC)"
    difficulty: medium
    description_md: |
      After sending `REPLCONF` to the master, the replica will receive a `OK` back.
      `OK` would be sent as a RESP simple string, like this : `+OK\r\n`

      After `REPLCONF`, the replica needs to send another [REPLCONF](https://redis.io/commands/replconf/) to the master next. (The official Redis implementation sends REPLCONF with its capabilities as the arguments, we are keeping this for compatibility with official Redis)

      Send REPLCONF with four strings as argument.
      The command would look like this :
      `REPLCONF capa eof capa psync2`
      Send it as a RESP array.
      The tester will not check for the exact strings, send any 4 strings.

      After sending this `REPLCONF` to the master, the replica will receive another `OK` back.
      `OK` would be sent as a RESP simple string, like this : `+OK\r\n`

      After `REPLCONF`, the replica needs to send PSYNC to the master next. You will learn about this more in a later stage.

      In this stage, you'll add support for accepting `OK` after the first `REPLCONF` message, then sent another `REPLCONF` with 4 string arguments, accept another `OK` and then send the `PSYNC` message.

      PSYNC should be sent with ? and -1 as arguments.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT> --replicaof <MASTER_HOST>:<MASTER_PORT>
      ```

      It'll expect to receive `PING` as the first command on the Master side. It will send `PONG` back. It'll then expect to receive `REPLCONF` as the second command on the Master side. It will send `OK` back. It'll then expect to receive another `REPLCONF` as the thirs command on the Master side. It will send `OK` again.
      Finally it will expect to receive `PSYNC ? -1` as the next command. The command should be sent as a RESP Array, like this :
      `*3\r\n$5\r\nPSYNC\r\n$1\r\n?\r\n$2\r\n-1\r\n`

    marketing_md: |
      In this stage, you'll add support for finishing the handshake from the Replica side, by sending PSYNC.

  - slug: "repl-master-replconf"
    primary_extension_slug: "replication"
    name: "Receive handshake 1/3 (Accept REPLCONF)"
    difficulty: easy
    description_md: |
      Now we will start implementing the handshake from the master side. (Till now we were acting as replicas and sending commands to the master, now we receive them as master).

      In this stage you'll add support for the [REPLCONF](https://redis.io/commands/replconf/) command on the Master redis server.
      You will receive the `REPLCONF` command with `listening-port` and `<PORT>` arguments.
      The client will send you the command as a RESP array, which looks something like this :

      ```
      *3\r\n$8\r\nREPLCONF\r\n$14\r\nlistening-port\r\n$4\r\n6380\r\n
      ```

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then send the `PING`, expecting a `PONG` back.

      ```bash
      $ redis-cli ping
      ```

      It'll then send the `REPLCONF` command with listening-port and <PORT> as arguments.

      ```bash
      $ redis-cli replconf listening-port <PORT>
      ```

      It'll expect to receive `OK` back. The command should be sent as a simple string, like this :
      `+OK\r\n`

    marketing_md: |
      In this stage, you'll add support for starting the handshake from the master side, by accepting REPLCONF.

  - slug: "repl-master-psync"
    primary_extension_slug: "replication"
    name: "Receive handshake 2/3 (Accept PSYNC)"
    difficulty: easy
    description_md: |
      When replicas connect to masters, they use the `PSYNC` command to send their old master replication ID and the offsets they processed so far. This way the master can send just the incremental part needed. However if there is not enough backlog in the master buffers, or if the replica is referring to an history (replication ID) which is no longer known, then a full resynchronization happens: in this case the replica will get a full copy of the dataset, from scratch.

      In this stage you'll add support for the [PSYNC](https://redis.io/commands/psync/) command on the Master redis server.
      You will receive the `PSYNC` command with `?` and `-1` arguments. (Which correspond to a Nil replication ID because the replica just started, and a 0 offset)
      The master would then need to do a fullsync, because based on the ID and offset, it will not be possible to send the incremental changes required.
      So, the Master will return `FULLRESYNC <REPL_ID> 0`

      The client will send you the PSYNC command as a RESP array, which looks something like this :

      ```
      *3,$5,PSYNC,$1,?,$2,-1,
      ```

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then send the `PING`, expecting a `PONG` back.

      ```bash
      $ redis-cli ping
      ```

      It'll then send the `REPLCONF` command with listening-port and <PORT> as arguments.

      ```bash
      $ redis-cli replconf listening-port <PORT>
      ```

      It'll expect to receive `OK` back. The command should be sent as a simple string, like this :
      `+OK\r\n`

      It'll then send the `PSYNC` command with ? and -1 as arguments.

      ```bash
      $ redis-cli psync ? -1
      ```

      It'll expect to receive `FULLRESYNC <REPL_ID> 0` back. The command should be sent as a simple string, like this :
      `+FULLRESYNC <ID> 0\r\n`
      Note : The ID will not be checked, you can send your master's replication ID.

    marketing_md: |
      In this stage, you'll add support for accepting PSYNC, and starting a FULLRESYNC.

  - slug: "repl-master-psync-rdb"
    primary_extension_slug: "replication"
    name: "Receive handshake 3/3 (Sending RDB file)"
    difficulty: easy
    description_md: |
      This is how a full synchronization works in more details:
      The master starts a background saving process to produce an RDB file. At the same time it starts to buffer all new write commands received from the clients. When the background saving is complete, the master transfers the database file to the replica, which saves it on disk, and then loads it into memory. The master will then send all buffered commands to the replica. This is done as a stream of commands and is in the same format of the Redis protocol itself.

      In this stage you'll add support for sending a RDB file to the replica, which it will load into its memory. (As RDB serialization is out of scope for this current extension, we will provide the file as a hex string to you.)

      The client will send you the PSYNC command as a RESP array, which looks something like this :

      ```
      *3,$5,PSYNC,$1,?,$2,-1,
      ```

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then send the `PING`, expecting a `PONG` back.

      ```bash
      $ redis-cli ping
      ```

      It'll then send the `REPLCONF` command with listening-port and <PORT> as arguments.

      ```bash
      $ redis-cli replconf listening-port <PORT>
      ```

      It'll expect to receive `OK` back. The command should be sent as a simple string, like this :
      `+OK\r\n`

      It'll then send the `PSYNC` command with ? and -1 as arguments.

      ```bash
      $ redis-cli psync ? -1
      ```

      It'll expect to receive `FULLRESYNC <REPL_ID> 0` back. The command should be sent as a simple string, like this :
      `+FULLRESYNC <ID> 0\r\n`
      Note : The ID will not be checked, you can send your master's replication ID.

      Subsequently it will expect a RDB file sent to it from the master.

      ### Notes
      - DO NOT send us the hex string provided to you.
      - Decode it, and send it as a RESP Bulk String. (Append the length of the file at the beginning)

    marketing_md: |
      In this stage, you'll add support for finishing the sync handshake from the master side, by sending a RDB file.

  - slug: "repl-master-cmd-prop"
    primary_extension_slug: "replication"
    name: "Command Propagation"
    difficulty: medium
    description_md: |
      The master keeps on buffering all write commands sent to it, while the replica processes the RDB file, and loads it into memory.
      And then when its ready it sends all the buffered commands as a stream to the replica.

      In this stage you'll add support for propagating write commands received by the Master server.
      You can relay the commands to the replica, as soon as you receive them without buffering.

      ### Tests

      The tester will execute your program like this:

      ```
      ./spawn_redis_server.sh --port <PORT>
      ```

      It'll then send the `PING`, expecting a `PONG` back.

      ```bash
      $ redis-cli ping
      ```

      It'll then send the `REPLCONF` command with listening-port and <PORT> as arguments.

      ```bash
      $ redis-cli replconf listening-port <PORT>
      ```

      It'll expect to receive `OK` back. The command should be sent as a simple string, like this :
      `+OK\r\n`

      It'll then send the `PSYNC` command with ? and -1 as arguments.

      ```bash
      $ redis-cli psync ? -1
      ```

      It'll expect to receive `FULLRESYNC <REPL_ID> 0` back. The command should be sent as a simple string, like this :
      `+FULLRESYNC <ID> 0\r\n`
      Note : The ID will not be checked, you can send your master's replication ID.

      Subsequently it will expect a RDB file sent to it from the master.

      It'll then send write commands to the master.

      ```bash
      $ redis-cli SET foo 1
      $ redis-cli SET bar 2
      $ redis-cli SET baz 3
      ```

      It'll then expect to receive the same commands propagated to the replica server.
      (The commands need to be sent as RESP messages)

    marketing_md: |
      In this stage, you'll add support for finishing the sync handshake from the master side, by sending a RDB file.
